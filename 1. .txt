1. 소프트웨어 생명 주기
  1) 소프트웨어 생명 주기(Software Life Cycle)
    - 소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 단계별로 나눈 것
  
  2) 폭포수 모형(Waterfall Model)
    - 각 단계를 확실히 매듭짓고 결과를 검토하여 승인 과정을 거친 후 다음 단계 진행하는 개발 방법론
    - 가장 오래됨
    - 고전적 생명 주기 모형
    - 모형을 적용한 경험과 성공 사례 많음
    - 다음 단계로 진행하기 위한 결과물이 명확하게 산출되어야 함

  3) 프로토타입 모형(Prototype Model, 원형 모형)
    - 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최종 결과물을 예측

  4) 나선형 모형(Spiral Model, 점진적 모형)
    - 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 모형
    - 보헴이 제안함
    - 폭포수 + 프토토타입 장점에 위험 분석 기능 추가
    - 누락되거나 추가된 요구사항 첨가 가능
    - 유지보수 과정 필요 없음
    - 4가지 활동
      - 계획 수림 -> 위험 분석 -> 개발 및 검증 -> 고객 평가
  
  5) 애자일 모형(Agile Model)
    - 요구사항 변화에 유연하게 대응하기 위해 일정한 주기를 반복해 개발하는 모형
    - 애자일 개발 핵심 가치
      - 개인과 상호작용에 더 가치를 둠
      - 방대한 문서보다 실행되는 SW에 더 가치를 둠
    - 대표적인 개발 모형
      - 스크럼(Scrum)
      - XP(eXtreme Programming)
      - 칸반(Kanban)
      - Lean
      - 기능 중심 개발(FDD: Feature Driven Development)
  
  6) 소프트웨어 공학(SE: Software Engineering)
    - 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문
    - 여러가지 방법론, 도구, 관리 기법들을 통해 소프트웨어 품질, 생산성 향상을 목표
    - 소프트웨어 공학의 기본 원칙
      - 현대적인 프로그래밍 지속적 적용
      - 개발된 소프트웨어 품질 유지되도록 지속적 검증
      - 개발 관련 사항 및 결과에 대한 명확한 기록 유지

2. 스크럼(Scrum) 기법
  1) 스크럼(Scrum)
    - 팀이 중심이 되어 개발의 효울성 높이는 기법
    
  2) 스크럼 팀
    - 제품 책임자(PO: Product Owner)
      - 요구 사항이 담긴 백로그 작성하는 주체
        * 백로그 : 요구사항을 모아 우선순위를 부여한 목록
      - 이해관계자들 중 개발될 제품에 대한 이해도가 높고 요구사항을 책임지고 의사를 결정할 사람으로 선정

    - 스크럼 마스터(SM: Scrum Master)
      - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할
    
    - 개발팀(DT: Development Team)
      - 위를 제외한 모든 팀원, 개발 수행

  3) 스크럼 개발 프로세스
    - 계획 -> 스프린트 -> 회의 -> 검토 => 회고

    - 스프린트 계획 회의(Sprint Planning Meeting)
      - 제품 백로그 중 이번 스프린트에서 수행할 작업 대상으로 단기 일정 수립하는 회의
    - 스프린트(Sprint)
      - 실제 개발 작업을 진행하는 과정, 2~4주
    - 일일 스크럼 회의(Daily Scrum Meeting)
      - 모든 팀원이 약속된 시간에 15분 정도 진행사항 점검
      - 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시
    - 스프린트 검토 회의(Sprint Review)
      - 부분 또는 전체가 요구사항에 잘 부합하는지 테스트
    - 스프린트 회고(Sprint Retrospective)
      - 정해놓은 규칙 준수 여부 및 개선할 점 확인하고 기록하는 것

3. XP(eXtreme Programming) 기법
  1) XP(eXtreme Programming)
    - 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법
    - 릴리즈 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성 높임
      * 릴리즈 : 몇 개의 요구사항이 적용되어 부분적으로 기능이 완료된 제품 제공
    - XP의 5가지 핵심 가치
      - 피드백, 존중, 의사소통, 용기, 단순성
      - 피존의 용기는 단순하다
  
  2) XP 개발 프로세스
    - 릴리즈 계획 수립(Release Planning)
      - 부분 혹은 전체 개발 완료 시점에 대한 일정 수립
    - 이터레이션(Iteration, 주기)
      - 개발 작업 진행 과정, 1~3주
    - 승인 검사(Acceptance Test, 인수 테스트)
      - 하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트
    - 소규모 릴리즈(Small Release)
      - 요구사항에 유연하게 대응할 수 있도록 릴리즈의 규모를 축소한 것
    
    - 사용자 스토리(User Story)
      - 요구사항을 간단한 시나리오로 표현
    - 스파이크(Spike)
      - 신뢰성 높이고 기술 문제 위험 감소하기 위한 별도의 간단한 프로그램

  3) XP의 주요 실천 방법(Practice)
    - Pair Programming(짝 프로그래밍)
      - 다른 사람과 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성함
    - Collective OwnerShip(공동 코드 소유)
      - 개발 코드에 대한 권한과 책임을 공동으로 소유함
    - Test-Driven Development(테스트 주도 개발)
      - 코드 작성 전에 테스트 케이스 먼저 작성해 자신이 뭘 해야할지 정확히 파악함
      - 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구를 사용함
    - Whole Team(전체 팀)
      - 모든 구성원들은 역할이 있고 책임을 가져야 함
    - Continuous Integration(계속적인 통합)
      - 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합됨
    - Refactoring(리팩토링)
      - 프로그램의 기능 변경 없이 시스템 재구성
      - 목적 : 프로그램을 쉽게 이해하고 빠르게 개발할 수 있도록 하기 위함
    - Small Releases(소규모 릴리즈)
      - 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응함

4. 개발 기술 환경 파악
  1) 개발 기술 환경 파악의 개요
    - 개발하고자 하는 소프트웨어와 관련된 OS, DBMS, 미들웨어 등 선정할 때 고려해야 할 사항 기술
      오픈 소스 사용 시 주의사항 제시
      * 미들웨어 : 운영체제와 운영체제 의해 실행되는 응용 프로그램 사이에서 추가적인 서비스 제공하는 소프트웨어
  2) 운영체제(OS: Operating System)
    - 컴퓨터 시스템의 자원을 효율적으로 관리하며, 컴퓨터를 편리하고 효율적으로 사용할 수 있돌고 환경 제공 소프트웨어
    - 운영체제 관련 요구사항 식별 시 고려사항
      - 기술 지원, 성능, 가용성, 주변 기기, 구축 비용(기성가주구)

  3) 데이터베이스 관리 시스템(DBMS: DataBase Management System)
    - 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어
    - 기존 파일 시스템이 갖는 데이터 종속성과 중복성 문제를 해결하기 위해 제안된 시스템
    - DBMS 관련 요구사항 식별 시 고려사항
      - 기술 지원, 성능, 가용성, 상호 호환성, 구축 비용(기성가상구)
  
  4) 웹 애플리케이션 서버(WAS: Web Application Server)
    - 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
    - 웹 애플리케이션 서버 관련 요구사항 식별 시 고려사항
      - 기술 지원, 성능, 가용성, 구축 비용(기성가구)
  
  5) 오픈 소스(Open Source)
    - 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어
    - 오픈 소스 관련 요구사항 식별 시 고려사항
      - 라이선스의 종류, 사용자의 수, 기술의 지속 가능성(라사기)

5. 요구사항 정의
  1) 요구사항
    - 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건

  2) 기능 요구사항(Functional requirements)
    - 기능이나 수행과 관련된 요구사항
    - 시스템 입출력에 무엇이 포함되어야 하는지
    - 어떤 데이터 저장, 연산 수행해야 하는지
    - 시스템이 반드시 수행해야 하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능

  3) 비기능 요구사항(Non-Functional requirements)
    - 품질이나 제약사항과 관련된 요구사항
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터를 구축하기 위해 필요한 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 품질 : 가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성 등
    - 프로젝트 관리 요구사항
    - 프로젝트 자원 요구사항

  4) 사용자 요구사항(User requirements)
    - 사용자 관점에서 본 시스템이 제공해야 할 요구사항
  
  5) 시스템 요구사항(System requirements)
    - 개발자 관점에서 본 시스템 전체가 제공해야 할 요구사항

6. 요구사항 개발 프로세스
  1) 요구사항 개발 프로세스
    - 요구사항을 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 활동
    - 요구사항 개발 프로세스가 진행되게 전에 타당성 조사가 선행되어야 함
      * 타당성 조사 : 개발 프로세스가 비즈니스 목적에 부합되는지 등에 대한 정보를 수집, 평가한 보고서를 토대로 수행
    - 요구공학의 한 요소
    - 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)

  2) 요구사항 도출(Requirement Elicitation, 요구사항 수집)
    - 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지를 식별하고 이해하는 과정
    - 이해관계자가 식별됨
    - 소프트웨어 개발 생명 주기(SDLC) 동안 반복
    - 요구사항 도출하는 주요 기법
      - 청취와 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스
  
  3) 요구사항 분석(Requirement Analysis)
    - 명확하지 않거나 모호한 요구사항을 걸러내기 위한 과정
    - 타당성 조사하고 비용과 일정에 대한 제약을 설정함
    - 요구사항 분석에 사용되는 대표적인 도구
      - 자료 흐름도(DFD), 자료 사전(DD)
  
  4) 요구사항 명세(Requirement Specification)
    - 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것
    - 기능 요구사항 빠짐없이 기술
    - 비기능 요구사항은 필요한 것만 기술
    - 구체적 명세를 위한 소단위 명세서(Mini-Spec) 사용될 수 있음

  5) 요구사항 확인(Requirement Validation, 요구사항 검증)
    - 요구사항 명세서가 정확하고 안전하게 작성되었는지를 검토하는 활동
    - 이해관계자들이 검토
    - 형상관리(SCM) 수행
      * 형상관리(SCM: Software Configuration Management) : 만들어진 문서 데이터 통칭하는 말, 변경 사항 관리

  6) 요구공학(Requirements Engineering)
    - 무엇을 개발해야 하는지 요구사항 정의, 분석 및 관리하는 프로세스를 연구하는 학문
    - 요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 실패를 최소화하는 것이 목표

  7) 요구사항 명세 기법
    - 정형 명세 기법
      - 수학적 원리 기반, 모델 기반
      - 수학적 기호, 정형화된 표기법
      - 요구사항 정확, 간결하게 표현
      - 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능
      - 표기법이 어려워 사용자가 이해하기 어려움
      - VDM, Z, Petri-net, CSP

    - 비정형 명세 기법
      - 상태/기능/객체 중심
      - 자연어 기반 서술 또는 다이어그램으로 작성
      - 작성자에 따라 다를 수 있어 일관성 떨어지고 해석이 달라질 수 있음
      - 내용의 이해가 쉬워 의사소통 쉬움
      - FSM, Decision Table, ER모델링, State Chart(SADT)

7. 요구사항 분석
  1) 요구사항 분석(Requirement Analysis)
    - 소프트웨어 개발의 실제적인 첫 단계
    - 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동

  2) 구조적 분석 기법
    - 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법
    - 하향식
    - 분석의 중복 배제 가능
    - 주요 구조적 분석 기법 도구
      - 자료 흐름도(FDD), 자료 사전(DD), 소단위 명세서(Mini-Spec), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서

  3) 자료 흐름도(DFD: Data Flow Diagram)
    - 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
    - 자료 흐름 그래프, 버블 차트
  
  4) 자료 흐름도 기본 기호
    - 프로세스(Process)
      - 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타내며 처리, 기능, 변환, 버블이라고도 함
    - 자료 흐름(Data Flow)
      - 자료의 이동(흐름)이나 연관관계를 나타냄
    - 자료 저장소(Data Store)
      - 시스템에서의 자료 저장소를 나타냄
    - 단말(Terminator)
      - 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음
  
  5) 자료 사전(DD: Data Dictionary)
    - 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것
    - 메타 데이터(Meta Data), 데이터의 데이터
    - 자료 사전에서 사용되는 표기 기호
      =  : 자료의 정의 : ~로 구성되어 있다(is composed of)
      +  : 자료의 연결 : 그리고(and)
      () : 자료의 생략 : 생략 가능한 자료(Optional)
      [] : 자료의 선택 : 또는(or)
      {} : 자료의 반복 : Iteration of
            ① {}n  : n번 이상 반복
            ② {}ⁿ  : 최대로 n번 반복
            ③ {}mⁿ : m 이상 n 이하로 반복 
      ** : 자료의 설명 : 주석(Comment)

9. UML(Unified Modeling Language)의 개요
  1) UML(Unified Modeling Language)
    - 시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
    - Rumbaugh(OMT), Booch, Jacobson 등의 객체지향 방법론의 장점을 통합함
    - OMG(Object Management Group)에서 표준으로 지정
    - UML 구성 요소
      - 사물(Things)
      - 관계(Relationships)
      - 다이어그램(Diagram)

  2) 사물(Things)
    - 다이어그램 안에서 관계가 형성될 수 있는 대상
    - 사물의 종류(그행 그주)
      - 구조 사물(Structural Things)  
        - 시스템의 개념적, 물리적 요소를 표현
        - 클래스, 유스케이스, 컴포넌트, 인터페이스, 노드 등
      - 행동 사물(Behavioral Things)
        - 시간과 공간에 따른 요소들의 행위를 표현
        - 상호작용, 상태 머신 등
      - 그룹 사물(Grouping Things)
        - 요소들을 그룹으로 묶어서 표현
        - 패키지
      - 주해 사물(Annotation Things)
        - 부가적인 설명이나 제약조건 등을 표현
        - 노트

10. UML - 관계(Relationship)
  1) 관계(Relationships)
    - 사물과 사물 사이의 연관성을 표현하는 것
    - 관계의 종류
      - 연관, 집합, 포함, 일반화, 의존, 실체화

  2) 연관(Association) 관계
    - 2개 이상의 사물이 서로 관련되어 있는 관계
    - 사물 사이를 실선으로 연결
    - 방향성은 화살표로 표현
    - 양방향 관계인 경우 화살표 생략, 실선으로만 연결
    - 다중도(참여하는 객체의 개수)를 선 위에 표기
     
      다중도         연관된 객체
      -------------------------------------
      1           : 1개
      n           : n개
      0..1        : 없거나 1개
      0..* 또는 * : 없거나 다수
      1..*        : 적어도 1개 이상
      n..*        : 적어도 n개 이상
      n..m        : 최소 n개에서 최대 m개

  3) 집합(Aggregation) 관계
    - 하나의 사물이 다른 사물에 포함되어 있는 관계
    - 포함하는 쪽과 포함되는 쪽은 독립적임
    - 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결하여 표현
    - 참조하는 값이 기본키가 아님

  4) 포함(Composition) 관계
    - 집합 관계의 특수한 형태, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
    - 포함하는 쪽과 포함되는 쪽은 독립될 수 없고 생명주기를 함께함
    - 포함되는 쪽에서 포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현
    - 참조하는 값이 기본키

  5) 일반화 관계(Generalization) 관계
    - 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계
    - 일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)
    - 구체적 -> 일반적인 사물 쪽으로 속이 빈 화살표 연결
    - 아메리카노, 에스프레소 -> 커피

  6) 의존(Dependency) 관계
    - 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
    - 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미침
    - 영향을 주는 사물이 영향을 받는 사물 쪽으로 점선 화살표 연결
    - 등급 ----> 할인율

  7) 실체화(Realization) 관계
    - 사물이 할 수 있거나 해야 하는 기능, 서로를 그룹화 할 수 있는 관계
    - 사물에서 기능 쪽으로 속이 빈 점선 화살표 연결
    - 비행기, 새 ----▷ 날 수 있다.

11. UML - 다이어그램
  1) 다이어그램(Diagram)
    - 사물과 관계를 도형으로 표현한 것
    - 뷰를 제공해 의사소통에 도움을 줌
    - 정적 모델링에서는 주로 구조적 다이어그램 사용
    - 동적 모델링에서는 주로 행위 다이어그램 사용

  2) 구조적(Structural) 다이어그램의 종류
    - 클래스 다이어그램(Class Diagram)
      - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현함
    
    - 객체 다이어그램(Object Diagram)
      - 클래스가 속한 사물들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
      - 럼바우 객체지향 분석 기법에서 객체 모델링에 활용됨
    
    - 컴포넌트 다이어그램(Component Diagram)
      - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
      - 구현 단계에서 사용

    - 배치 다이어그램(Deployment Diagram)
      - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
      - 구현 단계에서 사용
    
    - 복합체 구조 다이어그램(Composite Structure Diagram)
      - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현
    
    - 패키지 다이어그램(Package Diagram)
      - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계 표현

  3) 행위(Behavioral) 다이어그램의 종류(유순커뮤활동상태상타)
    - 유스케이스 다이어그램(Use Case Diagram)
      - 사용자의 요구를 분석하는 것, 기능 모델링 작업에 사용
      - 사용자(Actor)와 사용 사례(Use Case)로 구성됨
    
    - 순차 다이어그램(Sequence Diagram)
      - 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현
    
    - 커뮤니케이션 다이어그램(Communication Diagram)
      - 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계 표현

    - 활동 다이어그램(Activity Diagram)
      - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리 흐름 순서에 따라 표현
    
    - 상태 다이어그램(State Diagram)
      - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현
      - 럼바우 객체지향 분석 기법에서 동적 모델링에 활용

    - 상호작용 개요 다이어그램(Interaction Overview Diagram)
      - 상호작용 다이어그램 간의 제어 흐름을 표현함
    
    - 타이밍 다이어그램(Timing Diagram)
      - 객체 상태 변화와 시간 제약을 명시적으로 표현

  4) 스테레오 타입(Stereotype)
    - UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것
    - 길러멧(Guilemet) : <<>>
    - 주로 표현되는 형태
       <<include>>      : 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우
       <<extends>>      : 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우
       <<interface>>    : 인터페이스를 정의하는 경우
       <<exception>>    : 예외를 정의하는 경우
       <<constructor>>  : 생성자 역할을 수행하는 경우

14. 클래스(Class) 다이어그램
  1) 정적 모델링
    - 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조 표현
    - 시스템에 의해 처리되거나 생성될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점(View)에서 표현
    - 정적 모델링은 객체들을 클래스로 추상화하여 표현
    - UML을 이용한 정적 모델링의 대표적인 것이 클래스 다이어그램
  
  2) 클래스(Class) 다이어그램
    - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
    - 시스템 구성 요소에 대해 이해할 수 있는 구조적 다이어그램
    - 시스템 구성 요소를 문서화하는데 이용

  3) 클래스 다이어그램의 구성 요소
    - 클래스
      - 각각의 객체들이 갖는 속성과 오퍼레이션을 표현한 것
      - 3개 구획으로 나눠 이름, 속성, 오퍼레이션 표기
          - 속성 : 클래스 상태나 정보를 표현함
          - 오퍼레이션 : 클래스가 수행할 수 있는 동작, 함수

    - 제약 조건
      - 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적음
      - 클래스 안에 제약조건을 기술할 때는 중괄호{} 사용

    - 관계
      - 클래스와 클래스 사이의 연관성 표현
      - 클래스 다이어그램에는 연관 관계, 포함 관계, 일반화 관계, 의존 관계

  4) 연관 클래스
    - 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
    - 선의 가운데로부터 점선을 연관 클래스로 이어 표시
    - 연관 클래스의 이름은 연관 관계의 이름을 이용해 지정
  
15. 순차(Sequence) 다이어그램
  1) 동적 모델링
    - 시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것
    - 시스템 내부 구성 요소들 간에 이루어지는 동작이라는 관점에서 표현
    - 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점을 둠
    - 동적 모델링의 종류
      - 순차 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램
    
  2) 순차(Sequence) 다이어그램
    - 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것
    - 시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지 표현
    - 각 동작에 참여하는 시스템이나 객체들의 수행 기간 확인 가능
    - 객체들을 기본 단위로 하여 상호 작용을 표현
    
  3) 순차 다이어그램의 구성 요소
    - 액터(Actor)
      - 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미함
    
    - 객체(Object)
      - 메시지를 주고받는 객체

    - 생명선(Lifeline)
      - 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현
      - 객체 소멸(X)이 표시된 기간까지 존재

    - 실행 상자(Active Box, 활성 상자)
      - 객체가 메시지를 주고받으며 구동되고 있음을 표현

    - 메시지(Message)
      - 객체가 상호 작용을 위해 주고받는 메시지

    - 객체 소멸
      - 해당 객체가 더 이상 메모리에 존재하지 않음을 표현

    - 프레임(Frame)
      - 다이어그램의 전체 또는 일부를 묶어 표현한 것

18. 패키지(Package) 다이어그램
  1) 패키지(Package) 다이어그램
    - 유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것
    - 패키지는 또 다른 패키지의 요소가 될 수 있음
    - 대규모 시스템에서 주요 요소 간의 종속성을 파악하는 데 사용

  2) 패키지(Package) 다이어그램의 구성 요소
    - 패키지(Package)
      - 객체들을 그룹화한 것
      - 단순 표기법 : 패키지 안에 패키지 이름만 표현
      - 확장 표기법 : 패키지 안에 요소까지 표현

    - 객체(Object)
      - 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들

    - 의존 관계(Dependency)
      - 패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현
      - 스테레오타입을 이용해 의존 관계를 구체적 표현
      - 의존 관계의 표현 형태는 사용자가 임의로 작성할 수 있으며, 대표적으로 import와 access가 사용됨
        - <<import>> : 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계
        - <<access>> : 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계

20. S/W 공학의 발전적 추세
  1) 소프트웨어 재사용(Software Reuse)
    - 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
    - 품질과 생산성 높임
    - 기존 개발된 소프트웨어와 경험, 지식 등을 새로운 소프트웨어에 적용
    - 소프트웨어 재사용 방법
      - 합성 중심(Composition-Based)
        - 전자 칩과 같은 소프트웨어 부품
        - 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법, 블록 구성 방법
      - 생성 중심(Generation-Based)
        - 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법, 패턴 구성 방법

  2) 소프트웨어 재공학(Software Reengineering)
    - 기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것
    - 유지보수 비용이 개발 비용의 대부분을 차지하기 때문에 생산성 향상
    - 소프트웨어 재공학의 이점
      - 품질 향상, 생산성 증가, 수명 연장, 오류 감소

  3) CASE(Computer Aided Software Engineering)
    - 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를
      컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것
    - 객체지향 시스템, 구조적 시스템 등 다양한 시스템에서 활용되는 자동화 도구(CASE Tool)
    - 소프트웨어 생명 주기의 전체 단계를 연결하고 자동화하는 통합된 도구를 제공
    - 소프트웨어 개발 도구와 방법론이 결합됨, 정형화된 구조 및 방법을 소프트웨어 개발에 적용, 생산성 향상
    - CASE 주요 기능
      - 소프트웨어 생명 주기 전 단계의 연결
      - 다양한 소프트웨어 개발 모형 지원
      - 그래픽 지원

22. 비용 산정 기법 - 상향식
  1) 상향식 비용 산정 기법
    - 세부적인 작업 단위별로 비용을 산정 후 집계하여 전체 비용을 산정하는 방법
    - 주요 상향식 비용 산정 기법
      - LOC(원시 코드 라인 수) 기법
      - 개발 단계별 인월수 기법
      - 수학적 산정 기법
    
  2) LOC(원시 코드 라인 수, source Line Of Code)
    - 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하여 산정하는 기법
      * 비관치 : 가장 많이 측정된 코드 수
      * 낙관치 : 가장 적게 측정된 코드 수
      * 기대치 : 측정된 모든 코드 라인수의 평균
    - 측정이 가장 쉬움
    - 예측치 = (낙관치 + 4 * 기대치 + 비관치) / 6
    - 산정 공식
      - 노력(인월) = 개발 기간 * 투입 인원
                  = LOC / 1인당 월평균 생산 코드 라인 수
      - 개발 비용 = 노력(인월) * 단위 비용(1인당 월평균 인건비)
      - 개발 기간 = 노력(인월) / 투입 인원
      - 생산성 = LOC / 노력(인월)
  
  3) 개발 단계별 인월수(Effort Per Task) 기법
    - 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정
    - LOC보다 정확

23. 수학적 산정 기법
  1) 수학적 산정 기법
    - 상향식 비용 산정 기법으로, 경험적 추정 모형, 실험적 추정 모형히라고도 함
    - 개발 비용 산정의 자동화를 목표로 함
    - 공식은 과거의 유사한 프로젝트를 기반으로 유도됨
    - 주요 수학적 산정 기법
      - COCOMO 모형
      - Putnam 모형
      - 기능 점수(FP) 모형

  2) COCOMO(COnstructive COst MOdel) 모형
    - LOC에 의한 비용 산정 기법
    - 소프트웨어 규모를 예측 후 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용 산정
    - 비용 산정 결과는 프로젝트 완성을 위한 노력(Man-Month)로 나타남
    - 보헴이 제안

  3) COCOMO의 소프트웨어 개발 유형
    - 조직형(Organic Mode)
      - 기관 내부에서 개발된 중소규모의 소프트웨어
      - 일괄 자료 처리, 과학기술 계산, 비즈니스 자료 처리용 등 5만(50KDSI)라인 이하의 소프트웨어를 개발하는 유형
      - 사무 처리용, 업무용, 과학 응용 소프트웨어 개발에 적합

    - 반분리형(Semi-Detached Mod)
      - 조직형과 내장형의 중간형 소프트웨어
      - 트랜잭션 처리 시스템이나 운영체제, 디비 관리 시스템 등 30만(300KDSI) 라인 이하의 소프트웨어를 개발하는 유형
      - 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합

    - 내장형(Embedded Mode)
      - 초대형 규모의 소프트웨어
      - 트랜잭션 처리 시스템이나 운영체제 등의 30만(300KDSI) 라인 이상의 소프트웨어를 개발하는 유형
      - 신호기 제어, 미사일 유도, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합

  4) COCOMO 모형의 종류
    - 기본형(Basic) COCOMO
      - 소프트웨어의 크기와 개발 유형만을 이용하여 비용 산정
    
    - 중간형(Intermediate) COCOMO
      - 기본형 COCOMO의 공식을 토대로 사용하나, 다음 4가지 특성에 의해 비용을 산정함
        - 제품, 컴퓨터, 개발 요원, 프로젝트 특성

    - 발전형(Detailed) COCOMO
      - wndrksgud COCOMO를 보완하여 만들어진 모형
      - 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용 산정
      - 소프트웨어 환경과 구성 요소가 사전에 정의되어 있어야 함, 개발 과정의 후반부에 주로 적용

  5) Putnam 모형
    - 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형
    - 생명 주기 예측 모형
    - 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 분포도를 기초
    - 대형 프로젝트의 노력 분포 산정에 이용
    - 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소함
  
  6) 기능 점수(FP: Function Paint) 모형
    - 소프트웨어의 기능을 증대시키는 요인별로 가중치 부여
    - 요인별 가중치 합산하여 총 기능 점수 산출
    - 총 기능 점수와 영향도를 이용해 기능 점수(FP)를 구한 후 비용 산정
    - 알브레히트가 제안
    - 소프트웨어 기능 증대 요인
      - 자료 입력, 정보 출력, 명령어, 데이터 파일, 필요한 외부 루틴과의 인터페이스

  7) 비용 산정 자동화 추정 도구
    - SLIM
      - Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구

    - ESTIMACS
      - 다양한 프로젝트와 개인별 요소를 수용하도록 FP모형을 기초로 하여 개발된 자동화 추정 도구

24. 프로젝트 일정 계획
  1) 프로젝트 일정(Scheduling) 계획
    - 프로젝트의 프로세스를 이루는 소작업을 파악하고 예측된 노력을 각 소작업에 분배하여 순서를 정하는 것
    - 프로젝트 일정 계획에 사용되는 기능
      - WBS, PERT/CPM, 간트 차트

  2) PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술)
    - 전체 작업의 상호 관계를 표시하는 네트워크
    - 각 작업별로 단계를 나누어 종료시기 결정
      - 낙관적인 경우
      - 가능성이 있는 경우
      - 비관적인 경우
    - 개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용
    - 노드와 간선으로 구성, 원 노드에는 작업, 간선에는 낙관치, 기대치, 비관치 표시
    - 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있음
    - 작업 예측치 계산 공식
      - 작업 예측치 = (비관치 + 4 * 기대치 + 낙관치) / 6
      - 평방 편차   = [(비관치 - 낙관치) / 6]²
    
  3) CPM(Critical Path Method, 임계 경로 기법)
    - 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법
    - 노드와 간선으로 구성된 네트워크로 노드는 작업, 간선은 작업 사이의 전후 의존 관계를 나타냄
    - 원형 노드 : 각각의 작업을 의미, 작업 이름과 소요기간을 표시
    - 박스 노드 : 이정표을 의미, 이정표 이름과 예상 완료 시간 표시
  
  4) 간트 차트
    - 프로젝트의 각 작업들이 언제 시작하고 종료되는지에 대한 작업 일정을 막대도표를
      이용하여 표시하는 프로젝트 일정표
    - 시간선(Time-Line) 차트라고 함
    - 중간 목표 미달성 시 이유와 기간 예측 가능
    - 사용자와의 문제점이나 예산 초과 지출 등도 관리
    - 자원 배치와 인원 계획에 유용
    - 이정표, 작업 일정, 작업 기간, 산출물로 구성
    - 수평 막대의 길이는 각 작업(Task)의 기간을 나타냄
    
26. 소프트웨어 개발 표준
  1) 소프트웨어 개발 표준
    - 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용하는 국제 표준
    - 주요 소프트웨어 개발 표준
      - ISO/IEC 12207
      - CMMI(능력 성숙도 통합 모델)
      - SPICE(소프트웨어 처리 개선 및 능력 평가 기준)

  2) ISO/IEC 12207
    - ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스
    - 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준 제공
    - ISO/IEC 12207 구분
      - 기본 생명 주기 프로세스
        - 획득, 공급, 개발, 운영, 유지보수 프로세스
      - 지원 생명 주기 프로세스
        - 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스
      - 조직 생명 주기 프로세스
        - 관리, 기반 구조, 훈련, 개선 프로세스

  3) CMMI(Capability Maturity Model Integration)
    - 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델
    - 소프트웨어 공학연구소(SEI)에서 개발
    - CMMI의 소프트웨어 프로세스 성숙도
      - 초기(Initial)
        - 정의된 프로세스 없음
        - 작업자 능력에 따라 성공 여부 결정

      - 관리(Managed)
        - 규칙화된 프로세스
        - 특정한 프로젝트 내의 프로세스 정의 및 수행

      - 정의(Defined)
        - 표준화된 프로세스
        - 조직의 표준 프로세스를 활용하여 업무 수행

      - 정량적 관리(Quantitatively Managed)
        - 예측 가능한 프로세스
        - 프로젝트를 정량적으로 관리 및 통제

      - 최적화(Optimizing)
        - 지속적 개선 프로젝트
        - 프로세스 역량 향상을 위해 지속적인 프로세스 개선

  4) SPICE(Software Process Improvement and Capability dEtermination)
    - 소프트웨어 품질 및 생산성 향상을 위한 소프트웨어 프로세스를 평가 및 개선하는 국제 표준
    - 공식 명칭은 ISO/IEC 15504

  5) SPICE의 구성
    - 고객-공급자(Customer-Supplier) 프로세스
      - 소프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어의 정확한 운용 및 사용을 위한 프로세스로 구성
      - 구성 요소 : 인수, 공급, 요구 도출, 운영
      - 프로세스 수 : 10개

    - 공학(Engineering) 프로세스
      - 시스템과 소프트웨어 제품의 명세화, 구현, 유지보수를 하는데 사용되는 프로세스로 구성
      - 구성 요소 : 개발, 소프트웨어 유지보수
      - 프로세스 수 : 9개

    - 지원(Support) 프로세스
      - 소프트웨어 생명 주기에서 다른 프로세스에 의해 이용되는 프로세스로 구성
      - 구성 요소 : 문서화, 형상, 품질 보증, 검증, 확인, 리뷰, 감사, 품질 문제 해결
      - 프로세스 수 : 8개
    
    - 관리(Management) 프로세스
      - 소프트웨어 생명 주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성
      - 구성 요소 : 관리, 프로젝트 관리, 품질 및 위험 관리
      - 프로세스 수 : 4개

    - 조직(Organiztion) 프로세스
      - 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성
      - 구성 요소 : 조직 배치, 개선 활동 프로세스, 인력 관리, 기반 관리, 측정 도구, 재사용
      - 프로세수 수 : 9개

  6) SPICE의 프로세스 수행 능력 단계
    - 불완전(Incomplete) : 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계
    - 수행(Performed)    : 프로세스가 수행되고 목적이 달성된 단계
    - 관리(Managed)      : 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계
    - 확립(Established)  : 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계
    - 예측(Predictable)  : 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되게 수행되는 단계
    - 최적화(Optimizing) : 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계

28. 소프트웨어 개발 프레임워크
  1) 소프트웨어 개발 프레임워크
    - 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현하도록
      여러가지 기능들을 제공해주는 반제품 형태의 소프트웨어 시스템
    - 선행 사업자의 기술에 의존하지 않는 표준화된 개발 기반으로 사업자 종속성 해소
    - 소프트웨어 개발 프레임워크의 주요 기능
      - 예외 처리
      - 트랜잭션 처리
      - 메모리 공유
      - 데이터 소스 관리
      - 서비스 관리
      - 쿼리 서비스
      - 로깅 서비스
      - 사용자 인증 서비스
    - 소프트웨어 개발 프레임워크의 종류
      - 스프링 프레임워크
      - 전자정부 프레임워크
      - 닷넷 프레임워크

  2) 스프링 프레임워크
    - 자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크
    - 동적인 웹 사이트 개발을 위해 다양한 서비스 제공
    - 전자정부 표준 프레임워크의 기반 기술로 사용

  3) 전자정부 프레임워크
    - 대한민국의 공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한 기능 및
      아키텍처를 제공하는 프레임워크
    - 개발 프레임워크의 표준 정립으로 응용 소프트웨어의 표준화, 품질 및 재사용성의 향상을 목적으로 함
    - 오픈 소스 기반의 범용화 가능
    - 특정 업체의 종속성 배제 및 중복 개발 방지

  4) 닷넷 프레임워크(.NET Framework)
    - Windows 프로그램의 개발 및 실행 환경을 제공하는 프레임워크
    - Microsoft 사에서 통합 인터넷 전략을 위해 개발됨
    - 코드 실행 관리하는 CLR(Common Language Runtime, 공용 언어 런타임)이라는 이름의 가상 머신 상에서 작동

  5) 소프트웨어 개발 프레임워크의 특성
    - 모듈화(Modularity)
      - 캡슐화를 통해 모듈화를 강화하고 변경에 따른 영향을 최소화해서 품질 향상

    - 재사용성(Reusability)
      - 재사용 가능한 모듈을 제공

    - 확장성(Extensibility)
      - 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발 가능

    - 제어의 역흐름(Inversion of Control)
      - 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산을 향상시킴

















